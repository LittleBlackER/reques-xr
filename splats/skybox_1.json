{
  "attributes": {
    "aPosition":"POSITION"
  },
  "vshader":"\nattribute vec3 aPosition;\n        uniform mat4 matrix_model;\n        uniform mat4 matrix_viewProjection;\n        varying vec3 vWorldPos;\n        \n        void main(void) {\n            vec4 worldPos = matrix_model * vec4(aPosition, 1.0);\n            vWorldPos = worldPos.xyz;\n            gl_Position = matrix_viewProjection * worldPos;\n        }",
  "fshader": "\nprecision highp float;\n\nuniform vec3 iResolution;   // 视口分辨率\nuniform float uTime;        // 时间\n\nconst float PI  = 3.1415926535897932384626433832795;\nconst float TAU = 6.283185307179586476925286766559;\nconst float PHI = 1.6180339887498948482;\n\n// --- Icosahedron base ---\nvec3 vtx[12];\nivec3 faceIdx[20];\nvoid initIcosa() {\n    vec3 V[12] = vec3[](\n        vec3(-1.0,  PHI,  0.0), vec3( 1.0,  PHI,  0.0),\n        vec3(-1.0, -PHI,  0.0), vec3( 1.0, -PHI,  0.0),\n        vec3( 0.0, -1.0,  PHI), vec3( 0.0,  1.0,  PHI),\n        vec3( 0.0, -1.0, -PHI), vec3( 0.0,  1.0, -PHI),\n        vec3( PHI,  0.0, -1.0), vec3( PHI,  0.0,  1.0),\n        vec3(-PHI,  0.0, -1.0), vec3(-PHI,  0.0,  1.0)\n    );\n    for(int i=0;i<12;i++) vtx[i]=normalize(V[i]);\n    ivec3 F[20]=ivec3[](\n        ivec3(0,11,5), ivec3(0,5,1), ivec3(0,1,7), ivec3(0,7,10), ivec3(0,10,11),\n        ivec3(1,5,9), ivec3(5,11,4), ivec3(11,10,2), ivec3(10,7,6), ivec3(7,1,8),\n        ivec3(3,9,4), ivec3(3,4,2), ivec3(3,2,6), ivec3(3,6,8), ivec3(3,8,9),\n        ivec3(4,9,5), ivec3(2,4,11), ivec3(6,2,10), ivec3(8,6,7), ivec3(9,8,1)\n    );\n    for(int i=0;i<20;i++) faceIdx[i]=F[i];\n}\n\n// --- helpers ---\nvec3 dirFromLonLat(float lon,float lat){\n    float x=cos(lat)*sin(lon);\n    float y=sin(lat);\n    float z=cos(lat)*cos(lon);\n    return vec3(x,y,z);\n}\nfloat lineMask(float d,float thickness){\n    float aa=max(1e-4,fwidth(d));\n    return 1.0-smoothstep(thickness,thickness+aa,d);\n}\n\n// rotation matrices\nmat3 rotateXYZ(float ax, float ay, float az) {\n    float cx = cos(ax), sx = sin(ax);\n    float cy = cos(ay), sy = sin(ay);\n    float cz = cos(az), sz = sin(az);\n    mat3 rotX = mat3(1,0,0, 0,cx,-sx, 0,sx,cx);\n    mat3 rotY = mat3(cy,0,sy, 0,1,0, -sy,0,cy);\n    mat3 rotZ = mat3(cz,-sz,0, sz,cz,0, 0,0,1);\n    return rotZ * rotY * rotX;\n}\n\n// subdivided icosphere wireframe\nfloat icosaWire(vec3 dir,float edgeThickness,int subdiv){\n    float m=0.0;\n    for(int i=0;i<20;i++){\n        ivec3 f=faceIdx[i];\n        vec3 a=vtx[f.x],b=vtx[f.y],c=vtx[f.z];\n        for(int u=0;u<=subdiv;u++){\n            for(int v=0;v<=subdiv-u;v++){\n                vec3 p=normalize(mix(mix(a,b,float(u)/float(subdiv)),\n                                     mix(a,c,float(u)/float(subdiv)),float(v)/float(subdiv)));\n                if(u<subdiv){\n                    vec3 p2=normalize(mix(mix(a,b,float(u+1)/float(subdiv)),\n                                           mix(a,c,float(u+1)/float(subdiv)),float(v)/float(subdiv)));\n                    vec3 n=normalize(cross(p,p2));\n                    float d=abs(dot(n,dir));\n                    m=max(m,lineMask(d,edgeThickness));\n                }\n                if(v<subdiv-u){\n                    vec3 p3=normalize(mix(mix(a,b,float(u)/float(subdiv)),\n                                           mix(a,c,float(u)/float(subdiv)),float(v+1)/float(subdiv)));\n                    vec3 n=normalize(cross(p,p3));\n                    float d=abs(dot(n,dir));\n                    m=max(m,lineMask(d,edgeThickness));\n                }\n            }\n        }\n    }\n    return m;\n}\n\nvoid main(void) {\n    if(vtx[0]==vec3(0)) initIcosa();\n\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float lon=uv.x*TAU-PI;\n    float lat=uv.y*PI-0.5*PI;\n    vec3 dir=dirFromLonLat(lon,lat);\n\n    // ---- user controls ----\n    int   subdiv = 3;            // 线框密度 1~4\n    float edgeThickness = 0.002; // 线条粗细\n    vec3  rotSpeed = vec3(0.1, 0.2, 0.1); // 各轴旋转速度\n    vec3  rotDir   = vec3(0.3, -0.8, 0.2); // 各轴旋转方向 (+1/-1)\n\n    // ---- rotation ----\n    vec3 angle = uTime * rotSpeed * rotDir;\n    mat3 R = rotateXYZ(angle.x, angle.y, angle.z);\n    vec3 dirRot = R * dir;\n\n    // ---- draw wire ----\n    float wire = icosaWire(dirRot, edgeThickness, subdiv);\n\n    // ---- 红 → 蓝 动态渐变 ----\n    float scrollSpeed = -0.04;          // 垂直滚动速度\n    float repeat = 3.0;               // 渐变周期数\n    float t = fract(uv.y * repeat - scrollSpeed * uTime);\n\n    // 渐变色：红到深蓝\n    vec3 colorA = vec3(1.0, 0.1, 0.1); // 红\n    vec3 colorB = vec3(0.1, 0.1, 0.6); // 深蓝\n    vec3 gradColor = mix(colorA, colorB, t);\n\n    // 线条带色，背景纯黑\n    vec3 col = gradColor * wire;\n\n    gl_FragColor = vec4(col, 1.0);;\n}"
}
